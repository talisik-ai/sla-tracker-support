/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { clientsClaim } from 'workbox-core'
import { registerRoute } from 'workbox-routing'
import { CacheFirst, NetworkFirst } from 'workbox-strategies'
import { ExpirationPlugin } from 'workbox-expiration'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'

declare let self: ServiceWorkerGlobalScope

// Take control immediately
self.skipWaiting()
clientsClaim()

// Clean up old caches
cleanupOutdatedCaches()

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST)

// Cache Jira API responses
registerRoute(
  ({ url }) => url.hostname.includes('jira.com'),
  new NetworkFirst({
    cacheName: 'jira-api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 5, // 5 minutes
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
)

// Cache static assets
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'image' ||
    request.destination === 'font',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
)

// =====================================================
// NOTIFICATION HANDLERS - Desktop App Behavior
// =====================================================

/**
 * Handle notification click events
 * Opens the app and navigates to the relevant page
 */
self.addEventListener('notificationclick', (event) => {
  console.log('[SW] Notification clicked:', event.notification.tag)
  
  // Close the notification
  event.notification.close()
  
  // Get the URL to open (from notification data or default to root)
  const urlToOpen = event.notification.data?.url || '/'
  
  event.waitUntil(
    (async () => {
      // Get all window clients
      const windowClients = await self.clients.matchAll({
        type: 'window',
        includeUncontrolled: true,
      })
      
      // Check if the app is already open in a window
      for (const client of windowClients) {
        // If we found an existing window, focus it and navigate
        if ('focus' in client) {
          await client.focus()
          // Send message to navigate
          client.postMessage({
            type: 'NOTIFICATION_CLICK',
            url: urlToOpen,
          })
          return
        }
      }
      
      // No existing window found, open a new one
      if (self.clients.openWindow) {
        return self.clients.openWindow(urlToOpen)
      }
    })()
  )
})

/**
 * Handle notification close events (optional tracking)
 */
self.addEventListener('notificationclose', (event) => {
  console.log('[SW] Notification closed:', event.notification.tag)
})

/**
 * Handle push events (for future server push notifications)
 */
self.addEventListener('push', (event) => {
  console.log('[SW] Push event received')
  
  if (!event.data) {
    console.log('[SW] Push event has no data')
    return
  }
  
  try {
    const data = event.data.json()
    
    const options: NotificationOptions = {
      body: data.body || 'New notification',
      icon: data.icon || '/sla_dashboard_icon.png',
      badge: '/sla_dashboard_icon.png',
      tag: data.tag || 'sla-notification',
      requireInteraction: data.requireInteraction || false,
      data: {
        url: data.url || '/',
      },
    }
    
    event.waitUntil(
      self.registration.showNotification(data.title || 'SLA Tracker', options)
    )
  } catch (error) {
    console.error('[SW] Error handling push:', error)
  }
})

/**
 * Handle messages from the main thread
 */
self.addEventListener('message', (event) => {
  if (event.data?.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})

console.log('[SW] Service Worker initialized with notification support')

